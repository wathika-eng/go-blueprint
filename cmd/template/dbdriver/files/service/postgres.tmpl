package database

import (
	"context"
	"fmt"
	"log"
	"os"
	"sync"
	"time"

	"github.com/jackc/pgx/v5/pgxpool"
	_ "github.com/joho/godotenv/autoload"
)

type Service interface {
	Health() map[string]string
	Close() error
	GetPool() *pgxpool.Pool // Optional: useful for queries
}

type service struct {
	db *pgxpool.Pool
}

var (
	dbInstance *service
	once       sync.Once

	database = os.Getenv("DB_DATABASE")
	password = os.Getenv("DB_PASSWORD")
	username = os.Getenv("DB_USERNAME")
	port     = os.Getenv("DB_PORT")
	host     = os.Getenv("DB_HOST")
	schema   = os.Getenv("DB_SCHEMA")
)

func New() (Service, error) {
	var initErr error

	// Thread-safe singleton
	once.Do(func() {
		if database == "" || password == "" || username == "" || port == "" || host == "" {
			initErr = fmt.Errorf("database configuration is incomplete")
			return
		}

		connStr := fmt.Sprintf(
			"postgres://%s:%s@%s:%s/%s?sslmode=disable&search_path=%s",
			username, password, host, port, database, schema,
		)

		ctx, cancel := context.WithTimeout(context.Background(), 3*time.Second)
		defer cancel()

		// config, err := pgxpool.ParseConfig(connStr)
		// if err != nil {
		// 	initErr = fmt.Errorf("error parsing connection string: %v", err.Error())
		// 	return
		// }
		// config.MaxConns = int32(runtime.NumCPU())

		pool, err := pgxpool.New(ctx, connStr)
		if err != nil {
			initErr = fmt.Errorf("failed to connect to DB: %w", err)
			return
		}

		// Ping check
		if err := pool.Ping(ctx); err != nil {
			initErr = fmt.Errorf("db ping failed: %w", err)
			return
		}

		dbInstance = &service{db: pool}
		log.Printf("âœ… Connected to PostgreSQL: %s", database)
	})

	return dbInstance, initErr
}

func (s *service) Health() map[string]string {
	stats := make(map[string]string)

	// Basic check
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
	defer cancel()
	if err := s.db.Ping(ctx); err != nil {
		stats["status"] = "down"
		stats["error"] = err.Error()
		return stats
	}

	// Pool statistics
	p := s.db.Stat()
	stats["status"] = "up"
	stats["total_connections"] = fmt.Sprint(p.TotalConns())
	stats["acquired"] = fmt.Sprint(p.AcquiredConns())
	stats["idle"] = fmt.Sprint(p.IdleConns())
	stats["max"] = fmt.Sprint(p.MaxConns())
	stats["acquire_count"] = fmt.Sprint(p.AcquireCount())
	stats["acquire_wait"] = p.AcquireDuration().String()
	stats["message"] = "healthy"

	// Optional warnings
	if p.AcquiredConns() > p.MaxConns()/2 {
		stats["message"] = "High DB load: many active connections"
	}

	if p.AcquireCount() > 1000 {
		stats["message"] = "Frequent connection blocking"
	}

	return stats
}

func (s *service) Close() error {
	log.Printf("Disconnecting from PostgreSQL: %s", database)
	s.db.Close()
	return nil
}

func (s *service) GetPool() *pgxpool.Pool {
	return s.db
}
